@using EventPipelineHandler.Data
@using EventPipelineHandler.EventManager;
@using EventPipelineHandler.Services;
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using System.Text.Json;
@using Microsoft.EntityFrameworkCore;
@using Microsoft.AspNetCore.SignalR.Client
@page "/"
@inject ApplicationDbContext DbContext
@inject EventService EventService
@inject NavigationManager Navigation
@inject BackgroundTaskQueue BackgroundTaskQueue
@implements IAsyncDisposable

<PageTitle>Index</PageTitle>

<h1>View event actions</h1>
<button class="btn btn-primary" @onclick="() => GenerateEvents()">Generate events</button>

<table class="table">
    <thead>
        <tr>
            <th scope="col">
            </th>
            <th scope="col">Name</th>
            <th>Pipeline</th>
            <th scope="col">EventActionType</th>
            <th scope="col">Created At</th>
            <th scope="col"></th>
        </tr>
    </thead>
    <tbody>
        @foreach (var eventAction in EventActions)
        {
            <tr>
                <td scope="row">
                     @if (eventAction.EventActionState == EventActionState.InProgress)
                {
                    <i class="fas fa-spinner"></i>
                }
                else if (eventAction.EventActionState == EventActionState.Failed)
                {
                    <i class="fas fa-times"></i>
                }
                else if (eventAction.EventActionState == EventActionState.Done)
                {
                    <i class="fas fa-check"></i>
                }
                else if (eventAction.EventActionState == EventActionState.Pending)
                {
                    <i class="fas fa-hourglass-start"></i>
                }
                </td>
                <td>@eventAction.Name</td>
                <td>@eventAction.TreeLetter | Step @eventAction.Level</td>
                <td>@eventAction.EventActionType</td>
                <td>@eventAction.CreatedAt</td>
                <td>
                    <button class="btn btn-primary" disabled=@IsRerunDisabled(eventAction.EventActionState) @onclick="() => RerunEvent(eventAction)">Rerun event</button>
                </td>
            </tr>
        }
    </tbody>
</table>

<style>
    .table {
        color: white !important;
    }

    .fa-spinner {
      animation: spin 2s linear infinite;
    }

    .fa-times {
      color: #ff0000;
    }

    .fa-check {
      color: #00ff00;
    }

    @@keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    tr td {
        vertical-align: middle;
    }

</style>

@code 
{
    public List<EventAction> EventActions { get; set; } = new List<EventAction>();

    public List<Customer> Customers { get; set; } = new List<Customer>();

    private HubConnection? HubConnection;

    protected override async Task OnInitializedAsync()
    {
        await GetEvents();
        HubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/eventActionHub"))
            .Build();

        HubConnection.On<Guid, EventActionState>("EventActionStateUpdated", (eventId, eventActionState) =>
        {
            var eventAction = EventActions.FirstOrDefault(x => x.Id == eventId);

            if (eventAction != null)
            {
                eventAction.EventActionState = eventActionState;
                InvokeAsync(StateHasChanged);
            }
        });

        await HubConnection.StartAsync();
    }

    public async Task GetEvents()
    {
        EventActions = await EventService.GetEventActionsAsync();
        Customers = await DbContext.Customers.AsNoTracking().ToListAsync();
    }

    public bool IsConnected =>
        HubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync()
    {
        if (HubConnection is not null)
        {
            await HubConnection.DisposeAsync();
        }
    }

    public void RerunEvent(EventAction eventAction)
    {
        BackgroundTaskQueue.QueueEvent(eventAction);
        eventAction.EventActionState = EventActionState.InProgress;
    }

    private bool IsRerunDisabled(EventActionState state) => state != EventActionState.Failed;

    public async Task GenerateEvents()
    {
        await EventService.CreateTestEvents();
        await GetEvents();
    }
}